/*
题目：完全二叉树的公共父结点
问题描述
有一棵无限大的完全二叉树，该二叉树自上而下、自左而右从1开始编号。从某一个结点到根结点（编号是1的结点）
都有一条唯一的路径，比如从5到根结点的路径是（5, 2, 1），从4到根结点的路径是（4, 2, 1），
从根结点1到根结点的路径上只包含一个结点1，因此路径就是（1）。对于两个结点x和y，
假设他们到根结点的路径分别是（x1, x2, ... ,1）和（y1, y2,...,1），那么必然存在两个正整数i和j，
使得从xi 和yj 开始，有xi = yj，xi + 1 = yj + 1，xi + 2 = yj + 2，...
现在的问题就是，给定x和y，要求他们的最近公共父节点，即xi（也就是 yj）。
输入格式
	输入包含多组数据，每组数据包含两个正整数x和y（1≤x, y≤2^31-1）。
输出格式
	对应每一组数据，输出一个正整数xi，即它们的首个公共父节点。每输出一个数字后要换行。
样例输入
10 4
    0 0
样例输出
	2
样例说明
结点10到根结点的路径为（10,5,2,1），结点4到根节点的路径为（4,2,1），所以他们的首个公共父结点为2。
*/
#include<iostream>
int main()
{
    int m = 0, n = 0;
    while(scanf("%d%d",&m,&n)!=EOF && m && n){
        while(m != n){
            if(m > n) m /= 2;
            if(n > m) n /= 2;
        }
        printf("%d\n",m);
    }
    return 0;
}
